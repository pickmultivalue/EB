    SUBROUTINE EB_INP(CC,RR,INP.STRING,INP.FLD,LENTH,UNDERLINE.FLAG,INIT.FLAG,EB.CMD)
* @(#) EB_INP.b Ported to jBASE 07:23:52  18 FEB 2010
    INCLUDE EB.EQUS EB.COMMON
    IF LEN(CC) THEN
    IF LEN(RR) THEN
    CRT @(CC,RR):
END ELSE CRT @(CC):
END
INP_FLD = INP.FLD
IF RegInput THEN
IF UNDERLINE.FLAG THEN
CRT STR('_',LENTH):
CRT STR(BACK,LENTH):
END
IF INP.FLD<1> = 'YN' THEN
MTCH = "'Y'":@VM:"'N'":@VM:"'y'":@VM:"'n'"
END ELSE MTCH = "0X"
IF INIT.FLAG # @AM THEN
OLD.STRING = INIT.FLAG
END ELSE
IF UNASSIGNED(INP.STRING) THEN
OLD.STRING = ''
END ELSE
OLD.STRING = INP.STRING
END
END
IF INP.FLD<1> = 'YN' THEN OLD.STRING = 'NY'[OLD.STRING+1, 1]
CRT OLD.STRING:STR(BACK,LEN(OLD.STRING)):
LOOP
IF LENTH THEN
INPUT INP.STRING,LENTH:_
END ELSE
INPUT INP.STRING,LENTH:
END
UNTIL INP.STRING MATCHES MTCH DO
CRT STR(BACK,LEN(INP.STRING)):
REPEAT
FG$ACT.CODE = FALSE
IF INP_FLD<1> # 'LIT' THEN INP.STRING = TRIM(INP.STRING, ' ', 'T')
IF LEN(INP.STRING) THEN
LOCATE INP.STRING IN EB.CMD SETTING POS ELSE
LOCATE OCONV(INP.STRING, 'MCU') IN EB.CMD SETTING POS ELSE POS = FALSE
END
IF POS THEN
BEGIN CASE
CASE POS=1; FG$ACT.CODE = FG$ABT.CODE
CASE POS=3; FG$ACT.CODE = FG$EXIT.LN.CODE
CASE POS=8; FG$ACT.CODE = FG$OPT.CODE
CASE POS=15; FG$ACT.CODE = FG$HLP.CODE
END CASE
END
IF FG$ACT.CODE THEN RETURN
END ELSE
INP.STRING = OLD.STRING
END
IF LEN(CC) THEN
IF LEN(RR) THEN
CRT @(CC,RR):
END ELSE CRT @(CC):
END ELSE CRT STR(BACK,LEN(INP.STRING)):
FG$TYPEAHEAD.BUFF = INP.STRING:CR
IF INP.FLD<1> = 'YN' THEN INP.STRING = (OCONV(INP.STRING, 'MCU') = 'Y')
END
IF INP_FLD<4> = '' THEN INP_FLD<4> = CC:@VM:RR
!    IF LEN(INP_FLD<20>) = 0 THEN
!        INP_FLD<20> = EB_HELP
!    END
CALL EB_UT_WP(INP.STRING,INP_FLD,LENTH,UNDERLINE.FLAG,UMODE,CURS.ON,CURS.OFF,CURS.BLOCK,CURS.LINE,INIT.FLAG,ROW,HELP.ID1,EB.CMD)
IF INP_FLD<1> # 'LIT' THEN INP.STRING = TRIM(INP.STRING, ' ', 'T')
IF NOT(GETENV('EB_DEBUG',FG$DEBUG)) THEN FG$DEBUG = FALSE
IF FG$DEBUG THEN DEBUG
IF FG$TIMEDOUT THEN
FG$TIMEDOUT = FALSE
FG$ACT.CODE = FG$ABT.CODE
END
RETURN
