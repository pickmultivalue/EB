!
!BT.GOSUBS
!
!
!
RC.READ:! READ FULL HEADING
!
  IF RC.IRN = INT.IRN THEN
    RC.HEAD = INT.HEAD
  END ELSE
    READV RC.HEAD FROM MAIN,RC.IRN,RC.GRP THEN
      RC.HEAD = FIELD(RC.HEAD,"\",RC.ELN)
    END ELSE
      CRT "MAIN ":RC.IRN:" NOT ON FILE."
      CRT "AW.BTX.GOSUBS"
      DEBUG
    END
  END
  RETURN
!
ITEM.READ:!
!
  READ.FOUND = 1
  IF BTX.ID = PRFX THEN
    MATPARSE BTX.ITEM FROM ROOT.BTX.ITEM, AM;!{UD}
  END ELSE
    MATREAD BTX.ITEM FROM BTREE, BTX.ID ELSE
      READ.FOUND = 0
    END
  END
  IF READ.FOUND THEN
    IF BTX.ITEM(HEAD.PRFX) # "" THEN
!BTX.ITEM(HEAD.LIST) = CALLC aw_btx_exp(BTX.ITEM(HEAD.PRFX):AM:BTX.ITEM(HEAD.LIST), "") ;!{AWAIRS}
      HEADS = BTX.ITEM(HEAD.LIST) ;!{GENERIC}
      PREFIX = BTX.ITEM(HEAD.PRFX) ;!{GENERIC}
      GOSUB AW.BTX.EXP ;!{GENERIC}
      BTX.ITEM(HEAD.LIST) = HEADS ;!{GENERIC}
      BTX.ITEM(HEAD.PRFX) = ""
    END
!If required, add a tilde.
    IF BTX.ITEM(ADJ.ID) = "" THEN
      BTX.ITEM(HEAD.LIST)<1,-1> = RIGHT.EXT
    END
  END ELSE
    CRT "AW.BTX.GOSUBS"
    CRT "BTREE " : BTX.ID : " NOT ON FILE."
    DEBUG
  END
  RETURN
!
CHK.MAINT:! Check if item should be split (1) or merged (2).
!
!
! Don't try to merge the root.
! Always merge if the entry count is less than 2.
! Don't split until the entry count is greater than 3.
!
  TRMAINT = NO.MAINT
  IF (BTX.ITEM(INDX.CNT)>1) THEN
    LEN.BTX.ITEM = 0
    FOR I = 1 TO IRN.LIST
      LEN.BTX.ITEM = LEN.BTX.ITEM + LEN(BTX.ITEM(I))
    NEXT I
    BEGIN CASE
      CASE (LEN.BTX.ITEM > BTX.ITEM.MAX) AND (BTX.ITEM(INDX.CNT) > 3)
        TRMAINT = SPLIT.NODE
      CASE (LEN.BTX.ITEM < BTX.ITEM.MIN) AND (BTX.ID # PRFX)
        TRMAINT = MERGE.NODE
    END CASE
  END ELSE
    IF (BTX.ID # PRFX) THEN
      TRMAINT = MERGE.NODE
    END
  END
  RETURN
!
ITEM.WRITE:! COMPRESS HEADING LIST AND WRITE
!
  IF (DCOUNT(BTX.ITEM(HEAD.LIST),VM) -((BTX.ITEM(ADJ.ID)="") AND (BTX.ITEM(SEG.IDS) = ""))) # BTX.ITEM(INDX.CNT) THEN
    CRT "ITEM DISCREPANCY"
    DEBUG
    STOP
  END
!if present, strip the tilde.
  IF BTX.ITEM(ADJ.ID) = "" THEN
!    DEL BTX.ITEM(HEAD.LIST)<1,BTX.ITEM(INDX.CNT)+(BTX.ITEM(SEG.IDS)="")>
    DEL.VAL = BTX.ITEM(INDX.CNT) + (BTX.ITEM(SEG.IDS) = "")
    DEL BTX.ITEM(HEAD.LIST)<1, DEL.VAL>
  END
  HL = BTX.ITEM(HEAD.LIST)<1>
!BTX.ITEM(HEAD.LIST) = CALLC aw_btx_comp(BTX.ITEM(HEAD.LIST), "") ;!{AWAIRS}
  HEADS = BTX.ITEM(HEAD.LIST) ;!{GENERIC}
  GOSUB AW.BTX.COMP ;!{GENERIC}
  BTX.ITEM(HEAD.LIST) = HEADS ;!{GENERIC}
  BTX.ITEM(HEAD.PRFX) = PREFIX ;!{GENERIC}
!BTX.ITEM(HEAD.PRFX) = BTX.ITEM(HEAD.LIST)<1> ;!{AWAIRS}
!DEL BTX.ITEM(HEAD.LIST)<1> ;!{AWAIRS}
! apply right compression if flag set and no lower segments
  IF RC.FLG AND (BTX.ITEM(SEG.IDS) = "") THEN
!BTX.ITEM(HEAD.LIST) = CALLC aw_btx_rcomp(BTX.ITEM(HEAD.LIST), "") ;!{AWAIRS}
  END
!
! Keep the root segment locked.
!
  IF BTX.ID = PRFX THEN
    MATBUILD ROOT.BTX.ITEM FROM BTX.ITEM
  END ELSE
    MATWRITEU BTX.ITEM ON BTREE, BTX.ID
  END
!
  RETURN
!
! BTX BASIC FUNCTIONS
!
AW.BTX.COMP:! left compress - uses HEADS. Result placed in PREFIX
!
  PREFIX = ""
  BTXN = DCOUNT(HEADS,VM)
  IF (BTXN < 2) THEN RETURN
  BTX1 = HEADS<1,1>
  BTXL = HEADS<1,BTXN>
  BTXC = 0
  IF (LEN(BTX1) < LEN(BTXL)) THEN LBTX = LEN(BTX1) ELSE LBTX = LEN(BTXL)
  LOOP
    BTXC += 1
  WHILE (BTXC <= LBTX) AND (BTX1[BTXC,1] = BTXL[BTXC,1]) DO
    PREFIX := BTX1[BTXC,1]
  REPEAT
  IF (BTXC < 2) THEN RETURN
  FOR BTX1 = 1 TO BTXN
    HEADS<1,BTX1> = HEADS<1,BTX1>[BTXC,9999]
  NEXT BTX1
  RETURN
!
AW.BTX.RCOMP:! Not Implemented
  RETURN
!
AW.BTX.EXP:! left expand - uses HEADS and PREFIX
!
  IF (PREFIX = "") THEN RETURN
  CONVERT VM TO VM:PREFIX IN HEADS
  HEADS = PREFIX : HEADS
  RETURN
!
