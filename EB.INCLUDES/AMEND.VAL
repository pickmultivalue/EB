* @(#) AMEND.VAL Ported to jBASE 15:13:19  17 APR 2000
! Process 1 line
!
    SCRIPT=-1
    BEGIN CASE
    CASE FG$ACT=FG$LN.CMD
        FG$PROCESSING.FIELD=TRUE
        FG$PAGING=TRUE
        IF (TRIM(FG$SCR.TYPE<1,FG$FLD> 'R#2')[1,1])#'W' THEN
            JUST.LEN=FG$SCR.PAGE.LENS<1,FG$WINDOW>; JUST=FG$SCR.PAGE.JUSTS<1,FG$WINDOW>
            ORIG.LINE=''; CALL EB_READ_PANE
            FG$ACT=''
!
! process each field in the window
!
            FG$INPUT.POS=1; FG$INPUT.LIST=ST.WIN
            FOR FG$FLD=ST.WIN TO FI.WIN WHILE (FG$PROCESSING.FIELD AND FG$PAGING)
                GOSUB ENTER.FIELD
            NEXT FG$FLD
            IF FG$PAGING THEN
                FOR FG$FLD=ST.WIN TO FI.WIN
                    DFLD=FG$SCR.DATA.FLD<1,FG$FLD>; DAT(FG$FLD)<1,FG$PANE>=WIN.PANE(DFLD)
                NEXT FG$FLD
                IF FG$DISPLAY.LIST#'' THEN FG$REFRESH=6; CALL EB_REFRESH
            END
        END ELSE FG$FLD=ST.WIN; GOSUB ENTER.FIELD
        IF FG$NEXT.FLD THEN FG$FLD=FG$NEXT.FLD; GOSUB ENTER.FIELD
!
! Same as LN.CMD except continue processing subsequent lines
!
    CASE FG$ACT=FG$ULN.CMD
        FG$ACT=''; FG$PROCESSING.FIELD=TRUE; FG$PAGING=TRUE
        IF (TRIM(FG$SCR.TYPE<1,FG$FLD> 'R#2')[1,1])#'W' THEN
            JUST.LEN=FG$SCR.PAGE.LENS<1,FG$WINDOW>; JUST=FG$SCR.PAGE.JUSTS<1,FG$WINDOW>
            FG$INPUT.POS=1; FG$INPUT.LIST=ST.WIN
            LOOP
                ORIG.LINE=''; CALL EB_READ_PANE
                FOR FG$FLD=ST.WIN TO FI.WIN WHILE (FG$PROCESSING.FIELD AND FG$PAGING)
                    GOSUB ENTER.FIELD
                NEXT FG$FLD
            WHILE FG$PAGING AND FG$PANE<FG$NBR.PANES<1,FG$WINDOW> DO
                IF FG$PAGING THEN
                    FOR FG$FLD=ST.WIN TO FI.WIN
                        DFLD=FG$SCR.DATA.FLD<1,FG$FLD>; DAT(FG$FLD)<1,FG$PANE>=WIN.PANE(DFLD)
                    NEXT FG$FLD
                    IF FG$DISPLAY.LIST#'' THEN FG$REFRESH=6; CALL EB_REFRESH
                END
                FG$PANE=FG$PANE+1
            REPEAT
            FG$PAGING=FALSE
        END ELSE FG$FLD=ST.WIN; GOSUB ENTER.FIELD
        IF FG$NEXT.FLD THEN FG$FLD=FG$NEXT.FLD; GOSUB ENTER.FIELD
!
! Insert a line
!
    CASE FG$ACT=FG$INS.CMD
        IF FG$SCR.PAGE.MAX<1,FG$WINDOW>#'' AND FG$NBR.PANES<1,FG$WINDOW>>=FG$SCR.PAGE.MAX<1,FG$WINDOW> THEN
            CALL EB_ERRMSG(FG$ERROR.MSGS<10>)
            CALL EB_INPUT_ZERO(FG$ACT,60,23,FG$INPUT.CODES,'',0)
        END ELSE
            FG$AMEND=FALSE; FG$PAGING=TRUE; FG$FLD=ST.WIN; FG$INPUT.POS=1; FG$INPUT.LIST=FG$FLD; FG$WINDOW=FG$SCR.PAGING<1,FG$FLD>
            IF (TRIM(FG$SCR.TYPE<1,FG$FLD> 'R#2')[1,1])#'W' THEN
                MAT WIN.PANE=''; FG$INS.PANE=FG$PANE; GOTO START
            END ELSE GOSUB ENTER.FIELD; FG$AMEND=TRUE; FG$INS.PANE=0
        END
!
! Delete 1 or more lines
!
    CASE FG$ACT=FG$DLN.CMD
        IF TOTAL.PANES-LAST.LINE<FG$SCR.PAGE.MIN<1,FG$WINDOW> THEN
            CALL EB_ERRMSG(FG$ERROR.MSGS<11>:FG$SCR.PAGE.MIN<1,FG$WINDOW>)
            CALL EB_INPUT_ZERO(FG$ACT,60,23,FG$INPUT.CODES,'',0)
        END ELSE
            TOTAL.LIST=''; FG$LAST.PANE<1,FG$WINDOW>=FG$NBR.PANES<1,FG$WINDOW>
            IF FG$PANE#'' THEN
                IF LAST.LINE='' THEN LAST.LINE=FG$PANE
                GOSUB DELETE.LINES; IF FG$REFRESH=3 THEN GOSUB DEL.LINE.WRAP
            END ELSE
                IF INDEX(FG$HILINE<1,FG$WINDOW>,1,1) THEN
                    CALL EB_ERRMSG(FG$ERROR.MSGS<72>)
                    CALL EB_INPUT_ZERO(ANS,60,23,FG$INPUT.CODES,'N':VM:'T':VM:'U':AM:AM:'N',1)
                    DUMMY=INDEX('TU',ANS,1)
                    IF DUMMY THEN
                        DUMMY=MOD(DUMMY,2); ST=0; LAST.LINE=1; STMP=FG$HILINE<1,FG$WINDOW>
                        IF DUMMY THEN FI=DCOUNT(STMP,SVM) ELSE FI=FG$NBR.PANES<1,FG$WINDOW>
                        FOR FG$PANE=FI TO 1 STEP -1
                            IF STMP<1,1,FG$PANE>+0=DUMMY THEN GOSUB DELETE.LINES; IF FG$VALID THEN FG$DISPLAY.LIST<FG$WINDOW+1>=FG$PANE; ST=ST+1
                        NEXT FG$PANE
                        LAST.LINE=ST; IF FG$REFRESH=3 THEN GOSUB DEL.LINE.WRAP
                    END
                END
            END
        END
!
! Tag 1 or more lines
!
    CASE FG$ACT=FG$TAG.CMD
        STMP=FG$HILINE<1,FG$WINDOW>
        FI=NOT(STMP<1,1,FG$PANE>)
        FOR I=FG$PANE TO LAST.LINE
            STMP<1,1,I>=FI; FG$DISPLAY.LIST<1,-1>=I
        NEXT I
        FG$HILINE<1,FG$WINDOW>=STMP; FG$REFRESH=7; CALL EB_REFRESH
!
! Scroll forward or back current window
!
    CASE FG$ACT=FG$FWD.CMD OR FG$ACT=FG$BCK.CMD
        CALL EB_SCROLL_WINDOW(TOTAL.PANES)
!
! Replace string over multiple lines
!
    CASE FG$ACT=FG$REP.CMD
        STMP=FG$INPUT.CODES; FG$INPUT.CODES=FG$REPLACE.CODES
        CRT @(0,22):FG$ERROR.MSGS<4>:CLEOL:
        CALL EB_WP(OLD,'LIT',19,22,20,0); FG$INPUT.CODES=STMP
        IF FG$ACT.CODE THEN
            INCLUDE EB.INCLUDES ON.INP
            IF FG$ABORTED THEN GOTO AMEND.INPUT
        END
        IF OLD#'' THEN
            CRT @(0,22):FG$ERROR.MSGS<5>:CLEOL:
            FG$INPUT.CODES=FG$REPLACE.CODES
            CALL EB_WP(NEW,'LIT',19,22,20,0); FG$INPUT.CODES=STMP
            IF FG$ACT.CODE THEN
                INCLUDE EB.INCLUDES ON.INP
                IF FG$ABORTED THEN GOTO AMEND.INPUT
            END
            IF OLD#NEW THEN CALL EB_REPLACE(OLD,NEW,LAST.LINE)
        END
!
! Move or Copy fields
!
    CASE FG$ACT=FG$MV.CMD OR FG$ACT=FG$CP.CMD
        CALL EB_MV_LINES(TOTAL.PANES,NEW.PANE,LAST.LINE)
    END CASE
